<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8">
  <meta content="width=device-width, initial-scale=1.0" name="viewport">

  <title></title>
  <meta content="" name="description">
  <meta content="" name="keywords">

 <!-- Favicons -->
  <!--link href="assets/img/favicon.png" rel="icon">
  <link href="assets/img/apple-touch-icon.png" rel="apple-touch-icon"-->

  <!-- Google Fonts -->
  <link href="https://fonts.googleapis.com/css?family=Open+Sans:300,300i,400,400i,600,600i,700,700i|Raleway:300,300i,400,400i,600,600i,700,700i,900" rel="stylesheet">

  <!-- Vendor CSS Files -->
  <link href="assets/vendor/bootstrap/css/bootstrap.min.css" rel="stylesheet">
  <link href="assets/vendor/icofont/icofont.min.css" rel="stylesheet">
  <link href="assets/vendor/boxicons/css/boxicons.min.css" rel="stylesheet">
  <link href="assets/vendor/animate.css/animate.min.css" rel="stylesheet">
  <link href="assets/vendor/venobox/venobox.css" rel="stylesheet">
  <link href="assets/vendor/owl.carousel/assets/owl.carousel.min.css" rel="stylesheet">
  <link href="assets/vendor/aos/aos.css" rel="stylesheet">



  <!-- Template Main CSS File -->
  <link href="assets/css/style.css" rel="stylesheet">

  <style>
		.table-of-contents {
			/*height: 500px;*/
			width: 60%;
			/*opacity: 60%;*/
		}

		.inner-toc{
			background-color: white;
			color: black;
			margin-left: 30%;
			width: 45%;
			height: 500px;
			font: Arial;
			
		}

		.sub-list{
			list-style-type:disc;
			font-size: 13.5px;
		}

		.thick-line{
			height:3px;
			border:none;
			color:#333;
			background-color:#333;
			width:90%;
		}

		.topic-header{
			font-weight:bold;
			float:left;
			margin-left:15%;
		}

		.textbox {
			width: 90%;
			padding-left:10%;
			padding-top: 20px;
			font-family: Arial;
			line-height: 2;
			font-size: 18px;
		}
  </style>

  <!-- =======================================================
  * Template Name: Mamba - v2.5.0
  * Template URL: https://bootstrapmade.com/mamba-one-page-bootstrap-template-free/
  * Author: BootstrapMade.com
  * License: https://bootstrapmade.com/license/
  ======================================================== -->
</head>


<body>

	
	

  <!-- ======= Top Bar ======= -->
  <section id="topbar" class="d-none d-lg-block">
    <div class="container clearfix">
      <div class="contact-info float-left">
        <i class="icofont-envelope"></i><a href="mailto:mehul.choksi98@gmail.com">mehul.choksi98@gmail.com</a>
      </div>
      <div class="social-links float-right">
        <a href="https://www.linkedin.com/in/mehul-choksi-70b606184" class="linkedin"><i class="icofont-linkedin"></i></i></a>
        <a href="https://www.facebook.com/mehul.choksi.37/" class="facebook"><i class="icofont-facebook"></i></a>
        <a href="https://twitter.com/MehulChoksi98" class="twitter"><i class="icofont-twitter"></i></a>
      </div>
    </div>
  </section>

  <!-- ======= Header ======= -->
  <header id="header">
    <div class="container">

      <div class="logo float-left">
        <h1 class="text-light"><a href="index.html"><span>Mehul Choksi</span></a></h1>
        <!-- Uncomment below if you prefer to use an image logo -->
        <!-- <a href="index.html"><img src="assets/img/logo.png" alt="" class="img-fluid"></a>-->
      </div>

      <nav class="nav-menu float-right d-none d-lg-block">
        <ul>
          <li class="active"><a href="index.html">Home</a></li>

          <li><a href="#portfolio">Projects</a></li>
          <li class="drop-down"><a href="">Articles</a>
            <ul>
              <li><a href="dsa.html"> Data Structures and Algorithms</a></li>
              <li><a href="system-design.html">System Design</a></li>
              <li><a href="cloud.html">Cloud</a></li>
            </ul>
          </li>
          <li><a href="#contact">Contact Me</a></li>
        </ul>
      </nav><!-- .nav-menu -->

    </div>
  </header><!-- End Header -->

	

		<center>
		<div class="animate__animated animate__fadeInUp">
		<div class="table-of-contents" style="background-image: url('assets/img/articles/Problem-solving-RS2.jpg'); ">
				              
				<div class="carousel-content container" >
                <!--h2 class="animate__animated animate__fadeInDown">Mehul Choksi</h2>
                <p class="animate__animated animate__fadeInUp">Hi! I am a Comp Science Grad from PICT, Pune. My interests are web development, data processing, dev ops and cloud. </p-->
				
				<div class="inner-toc">
					<br/><br/>
					<h3>Dynamic Programming</h3>
					<br/>
					<p>Table of contents</p>
					<center><hr class="thick-line"/></center>
					<br/>
					<ol style="text-align:left;">
						<li>Introduction - What is DP?</li>
						<ul class="sub-list">
							<li>Why should I care about DP?</li>
							<li>Optimal substructure property</li>
							<li>Overlapping subproblems property</li>
							<li>Memoization vs tabulation</li>
							<li>Thinking in DP: Parameters, states and transitions</li>
						</ul>
						</br><hr class="thick-line"/>
						<li>AtCoder DP Contest: Problem A-J collection</li>
						<ul class="sub-list">
							<li>AtCoder Frog 1 & 2</li>
							<li>AtCoder Vacation</li>
							<li>Knapsack 1</li>
							<li>Knapsack 2</li>
							<li>LCS</li>
							<li>Longest Path</li>
							<li>Grid 1</li>
							<li>Coins</li>
							<li>Sushi</li>
						</ul>
						</br><hr class="thick-line"/>
					</ol>
					
				</div>
				</div>
				
              </div>
        </div>
		</center>
		<br/><br/><br/><br/><br/><br/><br/><br/>
		<div class="textbox">
			<h3 style="">Introduction: What is DP?</h3>
			<br/>
			<center><img src="./assets/img/articles/dp_quote.png"></center>
			<center><small><i>Why should I care about DP? DP problems are also solvable by recursion, but recursion is mostly exponential in complexity, making their scope is very limited. </i></small></center>
			<br/>
			<p>
				Dynamic Programming is an algorithmic paradigm that is used to solve a specific class of problems. All the problems solvable by DP have 2 main properties: <b>Optimal Substructure property</b> and <b>Overlapping subproblems </b>. 
			</p>

			<p><b>Optimal substructure</b>: The optimal solution of a problem can be achieved by using optimal solutions to the subproblems. In other words, if you can solve the <b>subproblems correctly and optimally</b>, you will be able to arrive at the <b>optimal solution by combining the solutions of subproblems</b> according to the required mathematical recurrence.</p>
			 
			<p>
				<b>Overlapping subproblems</b>: DP requires the <b>same subproblems over and over again</b> to arrive at the solution. So, if we are able to store the solutions to the subproblems, we can optimise our approach <b> by avoiding solving the same problem repeatedly.</b>
			</p>

			<table class="table">
	  <thead style="background-color:#003366;color:white;">
		<tr>
		  <th scope="col">#</th>
		  <th scope="col">Aspect</th>
		  <th scope="col">Memoization</th>
		  <th scope="col">Tabulation</th>
		</tr>
	  </thead>
	  <tbody>
		<tr>
		  <th scope="row">1</th>
		  <td>Way of solving</td>
		  <td>Top down</td>
		  <td>Bottom up</td>
		</tr>
		<tr>
		  <th scope="row">2</th>
		  <td>Explicit specification of ordering</td>
		  <td>Not required</td>
		  <td>Required</td>
		</tr>
		<tr>
		  <th scope="row">3</th>
		  <td>Implementation</td>
		  <td>Recursive</td>
		  <td>Iterative</td>
		</tr>
		<tr>
		  <th scope="row">4</th>
		  <td>Solving style</td>
		  <td>Solves only subproblems needed</td>
		  <td>Solves all subproblems</td>
		</tr>
	  </tbody>
	</table>

		<br/>

		<h4>Thinking in DP: Identifying parameters, states and transitions</h4><br/>

		<p>Solving a dp problem is a little methodological in nature. Following are the <b>critical</b> steps while approaching a dp problem: </p>
		<ol>
			<li>Think about the <b>base cases</b> of the problem. Helps you familiarize yourself with the problem.</li>
			<li>Formulate the states: States are the <b>necessary pieces of information</b> that can be used to <b>identify a subproblem accurately</b>. For example, in solving knapsack, the states would be the amount of capacity and the index upto which items are being considered.</li>
			<li>Identify the transitions: Identify how the various <b>subproblems</b> can be used to <b>solve a bigger problem</b> and formulate a mathematical relationship.</li>

		</ol>

		That's enough theory. Let's dive into problems! <br><br>

		<h3>Putting DP into practice: Problem collection</h3><br>
		<p>Note: If you're using python, using PyPy to submit on atcoder. Classic python gives tle even to the codes that have otherwise acceptable time complexities.</p>
	
		<a href="https://atcoder.jp/contests/dp/tasks" _target="blank">Link to atcoder dp contest</a><br>
		The above link is an excellent resource for dp practice, and I highly recommend checking it out.

			<ol>
			<li><h4>Frog A & B</h4></li>
				<a href="https://atcoder.jp/contests/dp/tasks/dp_a" _target="blank">Frog A </a><br>

				Solution to Frog A:

				<ol>
					<li>There's only 1 <b>state, which is the stone number on which the frog is on</b>. The subproblem can be framed as the min cost to reach i<sup>th</sup> stone. In terms of implementation, Dp[i] is the min cost for frog to reach the ith stone from 1st stone.</li>
					<li><b>Base case: dp[0] = 0</b>, because the cost of reaching to the current stone is zero</li>

					<li>Transitions: Frog on ith stone can either be reached from i-1th stone, or i-2th stone. According to the problem, Cost of hopping from xth stone to yth stone is |h[x] - h[y]|. <br/> In order words, <b>dp[i] = min(dp[i-1]+|h[i]-h[i-1]|), dp[i-2] + |h[i]-h[i-2]|)</b></li>
				</ol>

				<center><img src="./assets/img/articles/froga.png"></center>

				<br/>Now since we have defined the states,base cases and transitions, let us look at the code for frog A
				    
			<br/>

				<script src="http://gist-it.appspot.com//https://github.com/mehul-choksi/codes-for-site/blob/main/DynamicProgramming/froga.py"></script>	
			<br/>		
			<p>
				<a href="https://atcoder.jp/contests/dp/tasks/dp_b" _target="blank">Frog B </a><br>

				Frog B is extremely similar to frog A, except for the fact that we will be dealing with upto n transitions.
				<br/>
				In other words, <b>dp[i] = min(dp[i], dp[i-1] + |h[i]-h[i-1]|, dp[i-2] + |h[i] - h[i-2]|, ... , dp[i-k] + |h[i] - h[i-k]|)</b>
				<br/>

				<center><img src="./assets/img/articles/frogb.png"></center>
				<br/>				
				Here's the code for the code for the same: 
				<script src="http://gist-it.appspot.com//https://github.com/mehul-choksi/codes-for-site/blob/main/DynamicProgramming/frogb.py"></script>	
			</p>

			<li><h4>AtCoder Vacation</h4></li>

			<a href="https://atcoder.jp/contests/dp/tasks/dp_c" _target="blank">Frog B </a><br>

			<p>The problem asks you to find the max 'fun' given that no same activity can be done in 2 consecutive days.</p>
			Intuition: If activity a is done on day i, then activity that can be done on day i-1 can either be activity b or c.
			
			<ol>
				<li>Using the intuition, we can define the state of the dp as: <b>dp[i][j] be the max fun given that activity i is done at day j </b></li>
				<li>Dp array structure: dp[number of activies][days]. In other words, here it is a 3*n array</li>
				<li><b>Base cases: dp[0][0] = activity_a[0], dp[1][0] = activity_b[0], dp[2][0] = activity_c[0]</b></li>
				<li>Transitions: In English: <b>max possible value of activities other than the current activity until yesterday + today's activity.</b> <br/>
		Mathematically, 
						<br/>dp[0][i] = max(dp[1][i-1],dp[2][i-1]) + activity_a[i],
						<br/>dp[1][i] = max(dp[0][i-1], dp[2][i-1]) + activity_b[i],
						<br/>dp[2][i] = max(dp[0][i-1], dp[1][i-1]) + activity_c[i]		 
		
				<br/> Below is transition diagram for the 1st recurrence relation.

				<center><img src="./assets/img/articles/vacation.png"></center>

				Code for the same: <br/>
				<script src="http://gist-it.appspot.com//https://github.com/mehul-choksi/codes-for-site/blob/main/DynamicProgramming/vacation.py"></script>	
	
</li>
			</ol>

		<li><h4>Knapsack 1 </h4></li>
		<a href="https://atcoder.jp/contests/dp/tasks/dp_d" _target="blank">KnapSack 1 </a><br>
		<p>This problem is the classical 0/1 Knapsack problem. Given a set of n items each with weight w[i] and value v[i], and a sack which can hold atmost weight of W, find the maximum value you can hold using the sack. </p>
		
		<p>Approach: There are 2 parameters that are crucial in determining the problem's outcome.</p>
		<ol start="a">
			<li>The <b>index upto which the items are being considered</b></li>
			<li>The <b>capacity of the knapsack</b></li>
		</ol>

		
		These 2 are the states in this problem. More specifically, <b> dp[i][j] represents the max value obtainable considering items upto index i, with capacity j. </b>If you're having trouble coming up with the states, try writing the recursive code for knapsack first. The parameters that guide the recursion are the states.

		The recursive code looks something like this:<br/>

		<code style="color:#000080;">
			<b>
			# i: current index, C: capacity <br/>
			# call: f(N,W) <br/>
			f(i,C,w[],v[]): <br/>
				&nbsp;&nbsp;if i < 0: <br/>
					&nbsp;&nbsp;&nbsp;&nbsp;return 0 <br/>
				&nbsp;&nbsp;if w[i] > C: <br/>
					&nbsp;&nbsp;&nbsp;&nbsp;return f(i-1,C,w,v) <br/>
				&nbsp;&nbsp;return max(f(i-1,C,w,v), f(i-1,C-w[i],w,v) + v[i]) <br/>
			</b>
		</code>		

		<br/> Base cases: <b>For weight 0, all entries will be zero</b>

		<br/> Transitions: To reach the current state dp[i][j], it could 
			<br/>
			<b>either pick the current item and use the remaining capacity optimally, or</b>
			<br/>
			 <b>skip the current item and use the remaining capacity optimally </b> <br/>

			Mathematical recurrence for the same is: dp[i][j] = max(dp[i-1][j-w[i]] + v[i], dp[i-1][j])
			<br/>
			Transition diagram: <br/>

			<center><img src="./assets/img/articles/knapsacka.png"></center>
			Note: Handle the case where the current element is greater than capacity by an if-else.	
			<br/>

			Code: <br/>
		
			<script src="http://gist-it.appspot.com//https://github.com/mehul-choksi/codes-for-site/blob/main/DynamicProgramming/knapsacka.py"></script>

			<br/>

			<li><h4>AtCoder E: Knapsack 2</h4></li>
				
			<a href="https://atcoder.jp/contests/dp/tasks/dp_e" _target="blank">KnapSack 2 </a><br>

			<p>This is a variant to the knapsack, where the constraints on weights are larger ~(10<sup>9</sup>). So, our previous solution, which uses weight as one the states will make the problem computationally infeasible. However, take note of the constraints of values. No value is greater than 10<sup>5</sup>, and the maximum number of items is 100. In other words, the <b>sum of all values cannot be larger than 10<sup>7</sup></b>. Now the problem reduces to reframing the question, to use the 'value' state: (ranges from 0 to sum of all values). </p>
			

			<p>
				We reframe the question as follows: <b>Given a particular value, what is the minimum possible weight usable to get this value? </b>(Return infinity if it is not possible to reach the value). Then, we can iterate over the range of reachable values(0 to sum(val)) and get the largest value for which the answer(i.e the min weight) is <= knapsack's cap. <br/>

				Let us look at the states,base case, and transitions for this problem.
			</p>

			<ol>
				<li><b>State: dp[i][j] represents the minimum possible weight by using the first i items to get value j.</b> Array will be: dp[n][sum of values]</li>
				<li>Base case: dp[0][0] = 0, dp[0][v[0]] = w[0]</li>

				<li>Transition: Current state dp[i][j] can either be having the optimal solution by either <br/>
					<b>Ignoring the current item and using the optimal solution defined for i-1 items or</b> <br/>
					<b>Using the current item and optimal solution defined for leftover values for i-1 items</b> <br/>

					Transition rule: <b>dp[i][j] = min(dp[i-1][j], dp[i][j-v[i]] + w[i])</b> <br/>

					<center><img src="./assets/img/articles/knapsackb.png"></center>
					Note: During implementation handle the case where j < v[i]
				</li>	


				<li>Finally iterate over the last row (the solutions that include all elements) the find the max value for which the minimum possible weight is <= knapsack cap.</li>
			</ol>

			<br/> Implementation: 

			<script src="http://gist-it.appspot.com//https://github.com/mehul-choksi/codes-for-site/blob/main/DynamicProgramming/knapsackb.py"></script>

		<li><h4>Longest Common Subsequence (LCS)</h4></li>
					
		<a href="https://atcoder.jp/contests/dp/tasks/dp_f" _target="blank">LCS </a><br>
		<p>Classic LCS: Given strings s and t, find out (any one) longest common subsequence. Our strategy will be to first build the table for the finding optimal length of lcs, and then using the table to pick the lcs.</p>

		<br/> 

		<ol>
			<li>The states in this problem are the lengths upto which we are considering the strings. Specifically, <b> dp[i][j] represents the length of longest subsequence when considering first i characters of string s and first j characters of string t.</b> </li>

			<li>Dp table will be of form dp[len(s)+1][len(t)+1]</li>
			<li>Base case: <b>dp[0][0] = 0 </b></li>
			<li>Transition: Considering the lcs of strings s,t upto length i and j respectively. Now, <br/>
				<b> Either s[i] == t[j], in which case the optimal solution would be dp[i-1][j-1] + 1.</b> (Including both of the last characters from strings is better skipping one) <br/>
				Otherwise, the <b>characters do not match</b>, in which case we look for the optimal solution by <b>searching in the subproblems that consider i-1,j and i,j-1 states.</b> <br/>
				Transition rule: <br/>
				<code style="color:#000080;">
				<b>if s[i-1] == t[j-1]: #0 based indexing, hence then -1<br/>
	&nbsp;&nbsp;	dp[i][j] = dp[i-1][j-1] + 1 <br/>
				else: <br/>
	&nbsp;&nbsp;	dp[i][j] = max(dp[i-1][j],dp[i][j-1])</b>

				</code>

				<center><img src="./assets/img/articles/lcs.png"></center>

								
				<br/>
				
			</li>

			<li> Finally, we use the dp table to traverse accross the strings (in reverse) in an optimal manner to build the lcs. When there is a match, add the character. Otherwise decrement the pointer of the string whose subproblem's answer is greater.
			</li>
			
		</ol>

		<br/> Here's the implementation of the same: <br/>

		<script src="http://gist-it.appspot.com//https://github.com/mehul-choksi/codes-for-site/blob/main/DynamicProgramming/lcs.py"></script>

		<li><h4>Longest Path</h4></li>
		<a href="https://atcoder.jp/contests/dp/tasks/dp_g" _target="blank">Longest Path </a><br>
		<p>Given a Directed Acyclic Graph, find the length of the longest path.</p>

		<p>This problem requires the second style of dynammic programming, memoization. We write a recursive code and memoize it using a single state dp array, which remembers the solutions to the subproblems, so that they are not recomputed. The main idea is to use dfs on all vertices seperately, and return the max length of the path which starts from that vertex. </p>

		Note: One vertex might be involved in multiple paths, therefore it is not possible to arrive at a correct answer by just visiting the vertex once. <br/>

		This problem doesnt really require transition rules or diagrams, as it is simply a memoization over the classic recursive dfs. <br/>
		Below the implementation for the same: <br/>

		<script src="http://gist-it.appspot.com//https://github.com/mehul-choksi/codes-for-site/blob/main/DynamicProgramming/longestpath.py"></script>
		
		<li><h4>Grid 1</h4></li>
		<a href="https://atcoder.jp/contests/dp/tasks/dp_h" _target="blank">Grid 1 </a><br>
		<p>Given a grid with connectable rooms and blocked rooms, find the number of ways to reach the destination h,w from start 1,1.</p>
		
		<ol>
			<li>States: i,j: i for rows, j for columns. <b>dp[i][j] represents the number of ways to reach point i,j from 1,1</b></li>
			<li><b>Base cases: The first row and first column will be intialized with 1s, until there is a blocked room. Upon meeting a blocked room, the subsequent entries the row/column will all be 0.</b></li>
			<li>Transition: You can only move right or down, so a state can only be reached from preceeding left or up states. Also, it is never possible to reach a blocked room.<br/>
			Transition rule:<br/>

			<code style="color:#000080;">
			<b>

			if grid[i][j] is a connecting room:<br/>
&nbsp;&nbsp;	dp[i][j] = (dp[i][j-1] +  dp[i-1][j])<br/>
			</b>
			</code>
			</li>
			</ol>
			<br/>
			Here's the implementation for the same: <br/>
			<script src="http://gist-it.appspot.com//https://github.com/mehul-choksi/codes-for-site/blob/main/DynamicProgramming/grid.py"></script>

		<li><h4>Coins</h4></li>
		<a href="https://atcoder.jp/contests/dp/tasks/dp_i" _target="blank">Coins </a><br>
		<p>Given N coins and the probabilities of getting heads for each coins respectively, find the probability of getting more heads than tails. This is a nice introduction to probability dp problems. It's not really that different from a classic dp problem.</p>

		<ol>
			<li>States: i the number of tosses done, j number of heads. <b>dp[i][j] Probability of getting j heads in i tosses.Dp table: dp[n][n+1]</b></li>
			
			<li>Base case: dp[0][0]: 1 - p[0](Tails on toss 1), dp[0][1] = p[0](Heads on toss 1).</li>
			<li>Transition: 2 possiblities: <br/>
				<b>
				Heads on ith toss: -> Probability of heads on ith toss, then you multiply that with probability of getting j-1 heads upto i-1 tosses <br/>
				Tails on ith toss: -> Probability of tails on ith toss, multipied by the probability of getting j heads upto i-1 tosses. <br/>
				</b> 
			</li>
		</ol>

		Code: <br/>

		<script src="http://gist-it.appspot.com//https://github.com/mehul-choksi/codes-for-site/blob/main/DynamicProgramming/coins.py"></script>

		<li><h4>Final Problem: Sushi</h4></li>
		<a href="https://atcoder.jp/contests/dp/tasks/dp_j" _target="blank">Sushi</a><br>
		<p>This is difficult problem. The problem states that you are given n plates, where each plate is one of the 4 types of plates of sushis, plates with 3,2,1 and 0 sushis. You have to calculate the expected number of operations till all the plates are empty.</p>

		<p>Observation 1: The plates belonging to the same category are identical. This means that <b>order does not matter. We only need to concerned with the counts of 3-plates,2-plates,1-plates, and 0-plates.</b></p>

		<p>Observation 2: sum of all types of plates = n. Therefore we can rewrite 0-plates as: n - (3plates+ 2plates + 1plates), and avoid storing 0 plates as a seperate state.</p>
		<ol>
			<li>From Observation 1 and 2, we can see that the states needed are: 3-plates, 2-plates and 1 plates. <b>dp[i][j][k] represents the expected number of moves for i 3-plates, j 2-plates and k 1-plates.</b></li>
			<li>Base case: dp[0][0][0] = 0</li>
			<li>Transitions: <br/>
				Case 1: 3-plate is picked. 1 sushi is eaten, the <b>number of 3-plates reduce by 1, and the number of 2-plates increases by 1</b>. This contributes to the term <b>p3 * dp[i-1][j+1][k] </b>, where p3 is the probability of picking a 3-plate. <br><br>

				Case 2: 2-plate is picked. 1 sushi is eaten, the <b>number of 2-plates reduce by 1, and the number of 1-plates increases by 1</b>. This contributes to the term <b>p2 * dp[i][j-1][k+1]</b>, where p2 is the probability of picking a 2-plate. <br><br>

				Case 3: 1-plate is picked. 1 sushi is eaten, the <b>number of 1-plates reduce by 1, and the number of 0-plates increases by 1</b>. This contributes to the term <b>p1 * dp[i][j][k-1], where p1 is the probability of picking a 1-plate. <br><br>

				Case 4: 0-plate is picked. <b>No sushi is eaten, This contributes to the term p0 * dp[i][j][k], where p0 is the probability of picking a 0-plate. Because dp[i][j][k] is unknown, we can transpose this term to the LHS to work around this<b>. Detailed explanation is in the  code.<br><br>

				* Always add 1, because no matter what the choice, one move is going to be made.
			</li>
			<li>Invalid state elimation: During a loop, if i+j+k > n, it is invalid. Further, if i+j+k = 0, it is a trivial state and can be skipped. </li>

			<li>Ordering: Looking at the transitions, 3-plates state is dependent on 2-plates state, 2-plates-state is dependent on 1-plate state. Therefore, subproblems should be ordered such that the 1-plates should be calculated first, followed by 2 plate-states, followed by 1-plate state.</li>

			<br/>
		</ol>
			Below is the implementation: <br/>
			<script src="http://gist-it.appspot.com//https://github.com/mehul-choksi/codes-for-site/blob/main/DynamicProgramming/sushi.py"></script>
		
		<br/>
		<h3>Conclusion</h3>
		
		<p>In this article we talked about what dp is, the necessary theory behind it, followed by solving standard dp problems. At the end, I'd like to once again, emphasize the way of thinking in dp problems. To break it down, the flow goes like: Identify the problem is dp -> Come up with states and define the subproblems -> Come up with the transitions between the states and formulate the transition rules -> Observe the base cases and necessary constraints -> Implement. This requires some practice to get used to, but after solving a few problems, the whole process starts seeming more natural.</p>
		
		</div>
        
		



	

</body>

</html>
